{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gtracr - A GPU-accelerated Tracking Simulation for Cosmic Ray Trajectories Introduction This package is a high-performance 3-D tracking simulation of cosmic ray trajectories for different locations around the globe. The code can simulate cosmic ray trajectories that are detected at a certain altitude from some detector location, be it at Super-K in Kamioka, Japan or IceCube at the South Pole. The code utilizes the International Geomagnetic Reference Field (IGRF) model to represent the main magnetic field from Earth's outer core. The cosmic ray trajectories are described by a set of coupled ordinary differential equations based on the Lorentz force ($F_L = q(\\vec{v} \\times \\vec{B})$). The equations are expressed in spherical coordinates, the canonical coordinate system for performing calculations with spherical objects (i.e. the Earth). Since the analytical expression of the coordinate and momentum vector cannot be obtained, the evaluation of the trajectories are performed numerically by a 4th-order Runge-Kutta algorithm. This is considered one of the most simplest yet accurate methods used for numerical integration of all kinds. There are more accurate techniques that can be implemented to improve the accuracy of the results, but with a truncation error of $O(h^5)$, we can consider this algorithm already pretty good. Installation The package can be installed by using pip : pip install gtracr This allows module-level usage of the package. Alternative methods are available to download this package. The first method is to use setup.py with python : python setup.py install --user Note : The --user flag is required for installing the package in this manner. The lastest (unstable) version can be obtained by cloning the repository from the master branch in GitHub . Dependencies Python 3 and above NumPy SciPy datetime (for obtaining the current date) tqdm All such dependencies will be installed with the package. Optional requirements These packages are required to observe plots and test different trajectory cases: matplotlib, plotly for plots pytest, pytest-benchmark for testing Quickstart Evaluating a single trajectory Here we present a simple example that can be run in a Python script: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results # below module requires matplotlib and plotly to run from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" ) This will return a PlotLy interactive plot that will display on the default web browser, and saves the html for future access.","title":"Home"},{"location":"#gtracr-a-gpu-accelerated-tracking-simulation-for-cosmic-ray-trajectories","text":"","title":"gtracr - A GPU-accelerated Tracking Simulation for Cosmic Ray Trajectories"},{"location":"#introduction","text":"This package is a high-performance 3-D tracking simulation of cosmic ray trajectories for different locations around the globe. The code can simulate cosmic ray trajectories that are detected at a certain altitude from some detector location, be it at Super-K in Kamioka, Japan or IceCube at the South Pole. The code utilizes the International Geomagnetic Reference Field (IGRF) model to represent the main magnetic field from Earth's outer core. The cosmic ray trajectories are described by a set of coupled ordinary differential equations based on the Lorentz force ($F_L = q(\\vec{v} \\times \\vec{B})$). The equations are expressed in spherical coordinates, the canonical coordinate system for performing calculations with spherical objects (i.e. the Earth). Since the analytical expression of the coordinate and momentum vector cannot be obtained, the evaluation of the trajectories are performed numerically by a 4th-order Runge-Kutta algorithm. This is considered one of the most simplest yet accurate methods used for numerical integration of all kinds. There are more accurate techniques that can be implemented to improve the accuracy of the results, but with a truncation error of $O(h^5)$, we can consider this algorithm already pretty good.","title":"Introduction"},{"location":"#installation","text":"The package can be installed by using pip : pip install gtracr This allows module-level usage of the package. Alternative methods are available to download this package. The first method is to use setup.py with python : python setup.py install --user Note : The --user flag is required for installing the package in this manner. The lastest (unstable) version can be obtained by cloning the repository from the master branch in GitHub .","title":"Installation"},{"location":"#dependencies","text":"Python 3 and above NumPy SciPy datetime (for obtaining the current date) tqdm All such dependencies will be installed with the package.","title":"Dependencies"},{"location":"#optional-requirements","text":"These packages are required to observe plots and test different trajectory cases: matplotlib, plotly for plots pytest, pytest-benchmark for testing","title":"Optional requirements"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#evaluating-a-single-trajectory","text":"Here we present a simple example that can be run in a Python script: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results # below module requires matplotlib and plotly to run from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" ) This will return a PlotLy interactive plot that will display on the default web browser, and saves the html for future access.","title":"Evaluating a single trajectory"},{"location":"benchmarks/","text":"Benchmarks Coming soon!","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"Coming soon!","title":"Benchmarks"},{"location":"geomagnetic_cutoffs/","text":"Geomagnetic Cutoff Rigidities One of the key features of this code is to evaluate the geomagnetic cutoff rigidities of a certain location on the globe. The geomagnetic cutoff rigidity for a given location on Earth is defined as the minimum rigidity in which a cosmic ray can enter Earth's atmosphere at a certain arrival direction. We distinguish those that can enter the Earth's atmosphere as an allowed trajectory, and those which cannot as a forbidden one. As the cutoff between an allowed and forbidden trajectory is (in most cases) smooth,[^1] we can construct clear cutoff rigidities at each arrival direction of the particle. [^1]: At low enough rigidities and with lighter particles such smoothness may not apply (check Smart & Shea for more details). Evaluating the Geomagnetic Cutoff Rigidities The evaluation of the geomagnetic cutoff rigidities can be done in the following steps. 1. Initialize the Geomagnetic Cutoff Rigidity Evaluator We first have to initialize the container that performs the evaluation of the geomagntic cutoff rigidities and stores the relavent cutoff rigidities. We first import the module as such: from gtracr.geomagnetic_cutoffs import GMRC The container can then be initialized by providing the name of the location. For example, if we want to initialize the evaluator to determine the cutoff rigidities for the Kamioka site, we write the following code block: gmrc = GMRC(\"Kamioka\") One can additionally add some optional arguments for the evaluator: iter_num (int) : number of iterations for Monte Carlo sampling (default:10000) particle_altitude (float) : altitude in which cosmic ray collides with atmosphere (default:100) bfield_type (str) : type of magnetic field model to use (default: igrf) Note that only the name of the location is required to initialize the evaluator. 2. Evaluate the cutoff rigidities We then evaluate the geomagnetic cutoffs by using a Monte-Carlo sampling scheme. This can be done by using the following code: gmrc.evaluate() Some additional configurations can be set as follows: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s). 3. Plot the results We can then plot the results as a heatmap using the in-built heatmap plotting function. In order to plot this first, however, we need to interpolate the 2-D results, which is done by scipy.interpolate.griddata . We can perform this as such: interpd_gmrc_data = gmrc.interpolate_results() We can then plot our results on the heatmap: from gtracr.plotting import plot_gmrc_heatmap plot_gmrc_heatmap(interpd_gmrc_data, gmrc.rigidity_list, locname=gmrc.location, plabel=gmrc.plabel) Example The following example evaluates the geomagnetic cutoff rigidities and returns a 2-D heatmap of the interpolated results. from gtracr.geomagnetic_cutoffs import GMRC # initialize geomagnetic rigidity cutoff evaluator at Kamioka # with 10000 iterations gmrc = GMRC(\"Kamioka\") # evaluate with default stepsize and max_time gmrc.evaluate() # interpolate results interpd_gmrc_data = gmrc.interpolate_results() # create heatmap and save as png from gtracr.plotting import plot_gmrc_heatmap plot_gmrc_heatmap(interpd_gmrc_data, gmrc.rigidity_list, locname=gmrc.location, plabel=gmrc.plabel)","title":"Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#geomagnetic-cutoff-rigidities","text":"One of the key features of this code is to evaluate the geomagnetic cutoff rigidities of a certain location on the globe. The geomagnetic cutoff rigidity for a given location on Earth is defined as the minimum rigidity in which a cosmic ray can enter Earth's atmosphere at a certain arrival direction. We distinguish those that can enter the Earth's atmosphere as an allowed trajectory, and those which cannot as a forbidden one. As the cutoff between an allowed and forbidden trajectory is (in most cases) smooth,[^1] we can construct clear cutoff rigidities at each arrival direction of the particle. [^1]: At low enough rigidities and with lighter particles such smoothness may not apply (check Smart & Shea for more details).","title":"Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#evaluating-the-geomagnetic-cutoff-rigidities","text":"The evaluation of the geomagnetic cutoff rigidities can be done in the following steps.","title":"Evaluating the Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#1-initialize-the-geomagnetic-cutoff-rigidity-evaluator","text":"We first have to initialize the container that performs the evaluation of the geomagntic cutoff rigidities and stores the relavent cutoff rigidities. We first import the module as such: from gtracr.geomagnetic_cutoffs import GMRC The container can then be initialized by providing the name of the location. For example, if we want to initialize the evaluator to determine the cutoff rigidities for the Kamioka site, we write the following code block: gmrc = GMRC(\"Kamioka\") One can additionally add some optional arguments for the evaluator: iter_num (int) : number of iterations for Monte Carlo sampling (default:10000) particle_altitude (float) : altitude in which cosmic ray collides with atmosphere (default:100) bfield_type (str) : type of magnetic field model to use (default: igrf) Note that only the name of the location is required to initialize the evaluator.","title":"1. Initialize the Geomagnetic Cutoff Rigidity Evaluator"},{"location":"geomagnetic_cutoffs/#2-evaluate-the-cutoff-rigidities","text":"We then evaluate the geomagnetic cutoffs by using a Monte-Carlo sampling scheme. This can be done by using the following code: gmrc.evaluate() Some additional configurations can be set as follows: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s).","title":"2. Evaluate the cutoff rigidities"},{"location":"geomagnetic_cutoffs/#3-plot-the-results","text":"We can then plot the results as a heatmap using the in-built heatmap plotting function. In order to plot this first, however, we need to interpolate the 2-D results, which is done by scipy.interpolate.griddata . We can perform this as such: interpd_gmrc_data = gmrc.interpolate_results() We can then plot our results on the heatmap: from gtracr.plotting import plot_gmrc_heatmap plot_gmrc_heatmap(interpd_gmrc_data, gmrc.rigidity_list, locname=gmrc.location, plabel=gmrc.plabel)","title":"3. Plot the results"},{"location":"geomagnetic_cutoffs/#example","text":"The following example evaluates the geomagnetic cutoff rigidities and returns a 2-D heatmap of the interpolated results. from gtracr.geomagnetic_cutoffs import GMRC # initialize geomagnetic rigidity cutoff evaluator at Kamioka # with 10000 iterations gmrc = GMRC(\"Kamioka\") # evaluate with default stepsize and max_time gmrc.evaluate() # interpolate results interpd_gmrc_data = gmrc.interpolate_results() # create heatmap and save as png from gtracr.plotting import plot_gmrc_heatmap plot_gmrc_heatmap(interpd_gmrc_data, gmrc.rigidity_list, locname=gmrc.location, plabel=gmrc.plabel)","title":"Example"},{"location":"license/","text":"BSD 3-Clause License Copyright (c) 2020, Keito Watanabe All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"trajectory/","text":"Evaluating a Single Trajectory Evaluating a single trajectory can be done seamlessly with a few steps. 1. Initialize a Trajectory object. The first thing to do is to initalize the Trajectory object, which is a container for the specifications and initial configurations of the cosmic ray trajectory. To get the relavant module for the initialization of the trajectory: from gtracr.trajectory import Trajectory The required parameters to initialize the trajectory are as follows: location_name (str) : The name of the location in which we want to the detect the cosmic rays zenith_angle (float) : the zenith angle relative to the detector location in degrees ([0, 180]). Angles > 90 are for upwards-moving particles from the other end of the Earth. azimuth_angle (float) : the azimuthal angle relative to the detector location in degrees ([0, 360]). An angle of 0 degrees points to the Geographic South Pole. particle_altitude (float) : the altitude above sea level in which the cosmic ray arrives at in km rigidity (float) : the momentum per charge of the cosmic ray at the arrival location in GV For example, assume we want to simulate a cosmic ray that arrives at the horizon ( zenith_angle=90 ) from the West ( azimuth_angle=90 ) at 100km above sea level ( particle_altitude=100 ) at the Kamioka site ( location_name=\"Kamioka\" ) with a rigidity of 30 GV ( rigidity=30 ): traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90, azimuth_angle=90, particle_altitude=100, rigidity=30 ) There are other optional parameters that one can configure to initialize the Trajectory object. plabel (str) : the type of particle of the cosmic ray (default= \"p+\" ) energy (float) : the kinetic energy of the cosmic ray, which can be used instead of the rigidity to set the momentum of the cosmic ray (default= None ). Cannot be used concurrently with the rigidity. bfield_type (str) : the type of magnetic field model that is being used (default= igrf ). One can set this to dipole to use the dipole approximation of Earth's magnetic field instead. date (str) : the date (yyyy/mm/dd) in which we want to simulate the cosmic ray trajectory (default is set to the current date). This will change the value of the Gauss coefficients associated with the IGRF model. 2. Evaluate the trajectory The next step is to evaluate the cosmic ray trajectory by using the numerical integrator. There are a few parameters that can be set to modify the integration: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s). Additionally, one can choose either to obtain the data of the trajectory in a dictionary format by setting the option get_data=True . This dictionary will return the trajectory data of the six-vector in spherical coordinates as well as the time as an array. The keys of the dictionary are as follows: [\"t\", \"r\", \"theta\", \"phi\", \"pr\", \"ptheta\", \"pphi\"] The evaluation is performed simply by one function call: traj.get_trajectory() # without trajectory data trajectory_data = traj.get_trajectory(get_data=True) # with data Optional steps The following step are performed one desires to visualize the trajectory as a plot. 3. Plot the results We can now plot the trajectory. We can either plot this using matplotlib , a standard Python module for plotting, or PlotLy , a HTML interface for interactive plots. The desired method is using PlotLy , which allows for plots obtained from both Python scripts and Jupyter cells to produce an interactive plot. This can be done by the following script: from gtracr.plotting import plot_3dtraj plot_3dtraj( [trajectory_data], file_name = \"plot.png\", mpl=False, plot_path=\"../gtracr_plots\", title_name=\"Particle Trajectory\" ) There are several options available when visualizing the plot: file_name : the name of the file in which we save the plot to. This needs only to be the relative path within the directory in which the plot is saved in. This should have extensions in .html format for PlotLy plots, and some image format ( .png , .jpg etc) for matplotlib plots. mpl : choose whether to plot the trajectory using the matplotlib module with plt.axes(projection=\"3d\") (default : False). plot_dir : the path to the directory in which we store the plots. The default is set to \"gtracr_plots\", placed in parallel with the parent directory. title_name : the title of the plot. This should be changed to appropriately describe the trajectory plot. The plotter also implicitly converts the data (which is in spherical coordinates) into Cartesian coordinates. Note : To run this in JupyterLab, additional modeles are required to allow PlotLy to work. Check the PlotLy Installation Guide for more details. Running PlotLy on Jupyter Notebook still works without any additional requirements. Example Here we present a simple example that can be run in a Python script or a Jupyter Cell: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results from gtracr.plotting import plot_3dtraj plot_3dtraj( [trajectory_data], file_name = \"plot.html\" )","title":"Evaluating a Single Trajectory"},{"location":"trajectory/#evaluating-a-single-trajectory","text":"Evaluating a single trajectory can be done seamlessly with a few steps.","title":"Evaluating a Single Trajectory"},{"location":"trajectory/#1-initialize-a-trajectory-object","text":"The first thing to do is to initalize the Trajectory object, which is a container for the specifications and initial configurations of the cosmic ray trajectory. To get the relavant module for the initialization of the trajectory: from gtracr.trajectory import Trajectory The required parameters to initialize the trajectory are as follows: location_name (str) : The name of the location in which we want to the detect the cosmic rays zenith_angle (float) : the zenith angle relative to the detector location in degrees ([0, 180]). Angles > 90 are for upwards-moving particles from the other end of the Earth. azimuth_angle (float) : the azimuthal angle relative to the detector location in degrees ([0, 360]). An angle of 0 degrees points to the Geographic South Pole. particle_altitude (float) : the altitude above sea level in which the cosmic ray arrives at in km rigidity (float) : the momentum per charge of the cosmic ray at the arrival location in GV For example, assume we want to simulate a cosmic ray that arrives at the horizon ( zenith_angle=90 ) from the West ( azimuth_angle=90 ) at 100km above sea level ( particle_altitude=100 ) at the Kamioka site ( location_name=\"Kamioka\" ) with a rigidity of 30 GV ( rigidity=30 ): traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90, azimuth_angle=90, particle_altitude=100, rigidity=30 ) There are other optional parameters that one can configure to initialize the Trajectory object. plabel (str) : the type of particle of the cosmic ray (default= \"p+\" ) energy (float) : the kinetic energy of the cosmic ray, which can be used instead of the rigidity to set the momentum of the cosmic ray (default= None ). Cannot be used concurrently with the rigidity. bfield_type (str) : the type of magnetic field model that is being used (default= igrf ). One can set this to dipole to use the dipole approximation of Earth's magnetic field instead. date (str) : the date (yyyy/mm/dd) in which we want to simulate the cosmic ray trajectory (default is set to the current date). This will change the value of the Gauss coefficients associated with the IGRF model.","title":"1. Initialize a Trajectory object."},{"location":"trajectory/#2-evaluate-the-trajectory","text":"The next step is to evaluate the cosmic ray trajectory by using the numerical integrator. There are a few parameters that can be set to modify the integration: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s). Additionally, one can choose either to obtain the data of the trajectory in a dictionary format by setting the option get_data=True . This dictionary will return the trajectory data of the six-vector in spherical coordinates as well as the time as an array. The keys of the dictionary are as follows: [\"t\", \"r\", \"theta\", \"phi\", \"pr\", \"ptheta\", \"pphi\"] The evaluation is performed simply by one function call: traj.get_trajectory() # without trajectory data trajectory_data = traj.get_trajectory(get_data=True) # with data","title":"2. Evaluate the trajectory"},{"location":"trajectory/#optional-steps","text":"The following step are performed one desires to visualize the trajectory as a plot.","title":"Optional steps"},{"location":"trajectory/#3-plot-the-results","text":"We can now plot the trajectory. We can either plot this using matplotlib , a standard Python module for plotting, or PlotLy , a HTML interface for interactive plots. The desired method is using PlotLy , which allows for plots obtained from both Python scripts and Jupyter cells to produce an interactive plot. This can be done by the following script: from gtracr.plotting import plot_3dtraj plot_3dtraj( [trajectory_data], file_name = \"plot.png\", mpl=False, plot_path=\"../gtracr_plots\", title_name=\"Particle Trajectory\" ) There are several options available when visualizing the plot: file_name : the name of the file in which we save the plot to. This needs only to be the relative path within the directory in which the plot is saved in. This should have extensions in .html format for PlotLy plots, and some image format ( .png , .jpg etc) for matplotlib plots. mpl : choose whether to plot the trajectory using the matplotlib module with plt.axes(projection=\"3d\") (default : False). plot_dir : the path to the directory in which we store the plots. The default is set to \"gtracr_plots\", placed in parallel with the parent directory. title_name : the title of the plot. This should be changed to appropriately describe the trajectory plot. The plotter also implicitly converts the data (which is in spherical coordinates) into Cartesian coordinates. Note : To run this in JupyterLab, additional modeles are required to allow PlotLy to work. Check the PlotLy Installation Guide for more details. Running PlotLy on Jupyter Notebook still works without any additional requirements.","title":"3. Plot the results"},{"location":"trajectory/#example","text":"Here we present a simple example that can be run in a Python script or a Jupyter Cell: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results from gtracr.plotting import plot_3dtraj plot_3dtraj( [trajectory_data], file_name = \"plot.html\" )","title":"Example"}]}
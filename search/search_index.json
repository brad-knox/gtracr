{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gtracr - A GPU-accelerated Tracking Simulation for Cosmic Ray Trajectories Introduction This package is a high-performance 3-D tracking simulation of cosmic ray trajectories for different locations around the globe. The code can simulate cosmic ray trajectories that are detected at a certain altitude from some detector location, be it at Super-K in Kamioka, Japan or IceCube at the South Pole. The code utilizes the International Geomagnetic Reference Field (IGRF) model to represent the main magnetic field from Earth's outer core. The cosmic ray trajectories are described by a set of coupled ordinary differential equations based on the Lorentz force ($F_L = q(\\vec{v} \\times \\vec{B})$). The equations are expressed in spherical coordinates, the canonical coordinate system for performing calculations with spherical objects (i.e. the Earth). Since the analytical expression of the coordinate and momentum vector cannot be obtained, the evaluation of the trajectories are performed numerically by a 4th-order Runge-Kutta algorithm. This is considered one of the most simplest yet accurate methods used for numerical integration of all kinds. There are more accurate techniques that can be implemented to improve the accuracy of the results, but with a truncation error of $O(h^5)$, we can consider this algorithm already pretty good. In future versions,ff we will implement a better algorithm . The notion \"high-performance\" does not come without a meaning. We intend to create our package such that the evaluation of these trajectories can be performed with 1,000,000 particles simultaneously at approximately 5 seconds max! This is achieved by the aid of multi-threading, i.e. parallelization of processes across different threads of CPU / GPU cores. We intend to mainly utilize the thousands of GPU cores to perform such evaluations in a very fast manner. See the performance section for more details and benchmarks. This is not implemented yet, please wait for future versions! Installation The package can be installed by using pip : pip install gtracr This allows module-level usage of the package. Alternative methods are available to download this package. The first method is to use setup.py with python : python setup.py install --user Note : The --user flag is required for installing the package in this manner. The lastest (unstable) version can be obtained by cloning the repository from the master branch in GitHub . Dependencies Python 3 and above NumPy SciPy datetime (for obtaining the current date) tqdm All such dependencies will be installed with the package. Optional requirements These packages are required to observe plots and test different trajectory cases: matplotlib, plotly for plots pytest, pytest-benchmark for testing Quickstart Evaluating a single trajectory Here we present a simple example that can be run in a Python script: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results # below module requires matplotlib and plotly to run from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" ) This will return a PlotLy interactive plot that will display on the default web browser, and saves the html for future access.","title":"Home"},{"location":"#gtracr-a-gpu-accelerated-tracking-simulation-for-cosmic-ray-trajectories","text":"","title":"gtracr - A GPU-accelerated Tracking Simulation for Cosmic Ray Trajectories"},{"location":"#introduction","text":"This package is a high-performance 3-D tracking simulation of cosmic ray trajectories for different locations around the globe. The code can simulate cosmic ray trajectories that are detected at a certain altitude from some detector location, be it at Super-K in Kamioka, Japan or IceCube at the South Pole. The code utilizes the International Geomagnetic Reference Field (IGRF) model to represent the main magnetic field from Earth's outer core. The cosmic ray trajectories are described by a set of coupled ordinary differential equations based on the Lorentz force ($F_L = q(\\vec{v} \\times \\vec{B})$). The equations are expressed in spherical coordinates, the canonical coordinate system for performing calculations with spherical objects (i.e. the Earth). Since the analytical expression of the coordinate and momentum vector cannot be obtained, the evaluation of the trajectories are performed numerically by a 4th-order Runge-Kutta algorithm. This is considered one of the most simplest yet accurate methods used for numerical integration of all kinds. There are more accurate techniques that can be implemented to improve the accuracy of the results, but with a truncation error of $O(h^5)$, we can consider this algorithm already pretty good. In future versions,ff we will implement a better algorithm . The notion \"high-performance\" does not come without a meaning. We intend to create our package such that the evaluation of these trajectories can be performed with 1,000,000 particles simultaneously at approximately 5 seconds max! This is achieved by the aid of multi-threading, i.e. parallelization of processes across different threads of CPU / GPU cores. We intend to mainly utilize the thousands of GPU cores to perform such evaluations in a very fast manner. See the performance section for more details and benchmarks. This is not implemented yet, please wait for future versions!","title":"Introduction"},{"location":"#installation","text":"The package can be installed by using pip : pip install gtracr This allows module-level usage of the package. Alternative methods are available to download this package. The first method is to use setup.py with python : python setup.py install --user Note : The --user flag is required for installing the package in this manner. The lastest (unstable) version can be obtained by cloning the repository from the master branch in GitHub .","title":"Installation"},{"location":"#dependencies","text":"Python 3 and above NumPy SciPy datetime (for obtaining the current date) tqdm All such dependencies will be installed with the package.","title":"Dependencies"},{"location":"#optional-requirements","text":"These packages are required to observe plots and test different trajectory cases: matplotlib, plotly for plots pytest, pytest-benchmark for testing","title":"Optional requirements"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#evaluating-a-single-trajectory","text":"Here we present a simple example that can be run in a Python script: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results # below module requires matplotlib and plotly to run from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" ) This will return a PlotLy interactive plot that will display on the default web browser, and saves the html for future access.","title":"Evaluating a single trajectory"},{"location":"background/","text":"Background This code is a sub-project of a much larger project. The original intentions of this project is to aid the evaluation of the three-dimensional atmospheric neutrino flux with high performance. The evaluation of the atmospheric neutrino flux depends on various factors. The first factor is dependent on the probability of muon production $P_{\\mu, prod}$ within some wedge in the Earth's atmosphere. Of course, this depends on the number of particle interactions that occur within this \"packet\" of atmosphere depending on the energy of such particles. This will also influence the direction of propagation and momentum of the muon. Such values then affect the muon trajectory within the geomagnetic field. The probability of muon decay $P_{\\mu, dec}$ is then evaluated at each step based on the momentum of the muon. The distribution of the momentum magnitude along each direction is a key component, as this will influence the direction in which the neutrinos are produced (i.e. the probability of neutrino production in a certain solid angle relative to the muon $P_{\\nu, prod}$) in the muon decay. Lastly, we need to calculate the probability that the detector will detect $P_{\\nu, prod}$ number of neutrinos at a certain solid angle $P_{detect}$. As such, there are a total of 4 probability calculations required, and the atmospheric neutrino flux can be evaluated by the product of each of these probabilities (actually, even before all of these, we need to evaluate the energies in which cosmic rays can come towards Earth's atmosphere!). Additionally, this is done with $N_{part}$ many particles simultaneously! Essentially, there are a lot of calculations to perform. As one can imagine, the evaluation of the 3-D atmospheric neutrino flux has been a real computational challenge that many had a hard time to tackle. The current calculations, made by Honda, uses a Monte-Carlo approach in which he injects $N_{part}$ number of cosmic ray trajectories at random locations within an injection sphere in a Monte-Carlo-like manner. He then performs the calculations above for each cosmic ray. This works (as with most Monte-Carlo codes), but it is terribly slow, taking almost two weeks (as with most Monte-Carlo codes)! Today, we have a lot of new and modern computation methods available to us with new technologies emerging. As such, we want to use such technologies to upgrade the evaluation of the 3-D atmospheric neutrino flux using multi-threading with GPU cores. GPUs, or Graphical Processing Units, contain more than a thousand cores per unit. Since such trajectory evaluations are relatively simple, these cores can handle such evaluation processes. This means that we can perform such trajectory calculations simultaneously in the time of the calculation of one trajectory! As such, our goal is to create such a high-performance 3-D atmospheric neutrino flux calculator! This project will serve three key purposes for the atmospheric neutrino calculation: Evaluate the geomagnetic cutoff rigidities at a certain location on Earth (for example at IceCube). Evaluate the trajectories for muons, including the probability of muon decay throughout its propagation. Create an experimental platform for CORSIKA 8 with GPU acceleration (multi-threading with GPU cores). We hope to achieve these results in our package, and with the code being open-source, anyone with some GPU can run this very easily (we also hope to integrate CPU parallelization for those without GPUs)!","title":"Background"},{"location":"background/#background","text":"This code is a sub-project of a much larger project. The original intentions of this project is to aid the evaluation of the three-dimensional atmospheric neutrino flux with high performance. The evaluation of the atmospheric neutrino flux depends on various factors. The first factor is dependent on the probability of muon production $P_{\\mu, prod}$ within some wedge in the Earth's atmosphere. Of course, this depends on the number of particle interactions that occur within this \"packet\" of atmosphere depending on the energy of such particles. This will also influence the direction of propagation and momentum of the muon. Such values then affect the muon trajectory within the geomagnetic field. The probability of muon decay $P_{\\mu, dec}$ is then evaluated at each step based on the momentum of the muon. The distribution of the momentum magnitude along each direction is a key component, as this will influence the direction in which the neutrinos are produced (i.e. the probability of neutrino production in a certain solid angle relative to the muon $P_{\\nu, prod}$) in the muon decay. Lastly, we need to calculate the probability that the detector will detect $P_{\\nu, prod}$ number of neutrinos at a certain solid angle $P_{detect}$. As such, there are a total of 4 probability calculations required, and the atmospheric neutrino flux can be evaluated by the product of each of these probabilities (actually, even before all of these, we need to evaluate the energies in which cosmic rays can come towards Earth's atmosphere!). Additionally, this is done with $N_{part}$ many particles simultaneously! Essentially, there are a lot of calculations to perform. As one can imagine, the evaluation of the 3-D atmospheric neutrino flux has been a real computational challenge that many had a hard time to tackle. The current calculations, made by Honda, uses a Monte-Carlo approach in which he injects $N_{part}$ number of cosmic ray trajectories at random locations within an injection sphere in a Monte-Carlo-like manner. He then performs the calculations above for each cosmic ray. This works (as with most Monte-Carlo codes), but it is terribly slow, taking almost two weeks (as with most Monte-Carlo codes)! Today, we have a lot of new and modern computation methods available to us with new technologies emerging. As such, we want to use such technologies to upgrade the evaluation of the 3-D atmospheric neutrino flux using multi-threading with GPU cores. GPUs, or Graphical Processing Units, contain more than a thousand cores per unit. Since such trajectory evaluations are relatively simple, these cores can handle such evaluation processes. This means that we can perform such trajectory calculations simultaneously in the time of the calculation of one trajectory! As such, our goal is to create such a high-performance 3-D atmospheric neutrino flux calculator! This project will serve three key purposes for the atmospheric neutrino calculation: Evaluate the geomagnetic cutoff rigidities at a certain location on Earth (for example at IceCube). Evaluate the trajectories for muons, including the probability of muon decay throughout its propagation. Create an experimental platform for CORSIKA 8 with GPU acceleration (multi-threading with GPU cores). We hope to achieve these results in our package, and with the code being open-source, anyone with some GPU can run this very easily (we also hope to integrate CPU parallelization for those without GPUs)!","title":"Background"},{"location":"benchmarks/","text":"Benchmarks Coming soon!","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"Coming soon!","title":"Benchmarks"},{"location":"geomagnetic_cutoffs/","text":"Geomagnetic Cutoff Rigidities One of the key features of this code is to evaluate the geomagnetic cutoff rigidities of a certain location on the globe. The geomagnetic cutoff rigidity for a given location on Earth is defined as the minimum rigidity in which a cosmic ray can enter Earth's atmosphere at a certain arrival direction. We distinguish those that can enter the Earth's atmosphere as an allowed trajectory, and those which cannot as a forbidden one. As the cutoff between an allowed and forbidden trajectory is (in most cases) smooth,[^1] we can construct clear cutoff rigidities at each arrival direction of the particle. [^1]: At low enough rigidities and with lighter particles such smoothness may not apply (check Smart & Shea for more details). Evaluating the Geomagnetic Cutoff Rigidities The evaluation of the geomagnetic cutoff rigidities can be done in the following steps. 1. Initialize the Geomagnetic Cutoff Rigidity Evaluator We first have to initialize the container that performs the evaluation of the geomagntic cutoff rigidities and stores the relavent cutoff rigidities. We first import the module as such: from gtracr.geomagnetic_cutoffs import GMCutoffEvaluator The container can then be initialized by providing the name of the location. For example, if we want to initialize the evaluator to determine the cutoff rigidities for the Kamioka site, we write the following code block: gmcutoff_evaluator = GMCutoffEvaluator(\"Kamioka\") One can additionally add some optional arguments for the evaluator: Note that only the name of the location is required to initialize the evaluator. 2. Evaluate the cutoff rigidities We then evaluate the geomagnetic cutoffs by using a Monte-Carlo sampling scheme. This can be done by using the following code: gmcutoff_evaluator.evaluate() Some additional configurations can be set as follows: 3. Plot the results We can then plot the results as a heatmap using the in-built heatmap plotting function. In order to plot this first, however, we need to interpolate the 2-D results, which is done by scipy.interpolate.griddata . We can perform this as such: gmcutoff_evaluator.interpolate_results() We can then plot our results on the heatmap: from gtracr.lib.plotting import plot_gmcutoffs_heatmap plot_gmcutoff_heatmap(interpd_gmcutoff_data, gmcutoff_evaluator.rigidity_list, locname=gmcutoff_evaluator.location, plabel=plabel) Example Coming soon!","title":"Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#geomagnetic-cutoff-rigidities","text":"One of the key features of this code is to evaluate the geomagnetic cutoff rigidities of a certain location on the globe. The geomagnetic cutoff rigidity for a given location on Earth is defined as the minimum rigidity in which a cosmic ray can enter Earth's atmosphere at a certain arrival direction. We distinguish those that can enter the Earth's atmosphere as an allowed trajectory, and those which cannot as a forbidden one. As the cutoff between an allowed and forbidden trajectory is (in most cases) smooth,[^1] we can construct clear cutoff rigidities at each arrival direction of the particle. [^1]: At low enough rigidities and with lighter particles such smoothness may not apply (check Smart & Shea for more details).","title":"Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#evaluating-the-geomagnetic-cutoff-rigidities","text":"The evaluation of the geomagnetic cutoff rigidities can be done in the following steps.","title":"Evaluating the Geomagnetic Cutoff Rigidities"},{"location":"geomagnetic_cutoffs/#1-initialize-the-geomagnetic-cutoff-rigidity-evaluator","text":"We first have to initialize the container that performs the evaluation of the geomagntic cutoff rigidities and stores the relavent cutoff rigidities. We first import the module as such: from gtracr.geomagnetic_cutoffs import GMCutoffEvaluator The container can then be initialized by providing the name of the location. For example, if we want to initialize the evaluator to determine the cutoff rigidities for the Kamioka site, we write the following code block: gmcutoff_evaluator = GMCutoffEvaluator(\"Kamioka\") One can additionally add some optional arguments for the evaluator: Note that only the name of the location is required to initialize the evaluator.","title":"1. Initialize the Geomagnetic Cutoff Rigidity Evaluator"},{"location":"geomagnetic_cutoffs/#2-evaluate-the-cutoff-rigidities","text":"We then evaluate the geomagnetic cutoffs by using a Monte-Carlo sampling scheme. This can be done by using the following code: gmcutoff_evaluator.evaluate() Some additional configurations can be set as follows:","title":"2. Evaluate the cutoff rigidities"},{"location":"geomagnetic_cutoffs/#3-plot-the-results","text":"We can then plot the results as a heatmap using the in-built heatmap plotting function. In order to plot this first, however, we need to interpolate the 2-D results, which is done by scipy.interpolate.griddata . We can perform this as such: gmcutoff_evaluator.interpolate_results() We can then plot our results on the heatmap: from gtracr.lib.plotting import plot_gmcutoffs_heatmap plot_gmcutoff_heatmap(interpd_gmcutoff_data, gmcutoff_evaluator.rigidity_list, locname=gmcutoff_evaluator.location, plabel=plabel)","title":"3. Plot the results"},{"location":"geomagnetic_cutoffs/#example","text":"Coming soon!","title":"Example"},{"location":"license/","text":"BSD 3-Clause License Copyright (c) 2020, Keito Watanabe All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"trajectory/","text":"Evaluating a Single Trajectory Evaluating a single trajectory can be done seamlessly with a few steps. 1. Initialize a Trajectory object. The first thing to do is to initalize the Trajectory object, which is a container for the specifications and initial configurations of the cosmic ray trajectory. To get the relavant module for the initialization of the trajectory: from gtracr.trajectory import Trajectory The required parameters to initialize the trajectory are as follows: location_name (str) : The name of the location in which we want to the detect the cosmic rays zenith_angle (float) : the zenith angle relative to the detector location in degrees ([0, 180]). Angles > 90 are for upwards-moving particles from the other end of the Earth. azimuth_angle (float) : the azimuthal angle relative to the detector location in degrees ([0, 360]). An angle of 0 degrees points to the Geographic South Pole. particle_altitude (float) : the altitude above sea level in which the cosmic ray arrives at in km rigidity (float) : the momentum per charge of the cosmic ray at the arrival location in GV For example, assume we want to simulate a cosmic ray that arrives at the horizon ( zenith_angle=90 ) from the West ( azimuth_angle=90 ) at 100km above sea level ( particle_altitude=100 ) at the Kamioka site ( location_name=\"Kamioka\" ) with a rigidity of 30 GV ( rigidity=30 ): traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90, azimuth_angle=90, particle_altitude=100, rigidity=30 ) There are other optional parameters that one can configure to initialize the Trajectory object. plabel (str) : the type of particle of the cosmic ray (default= \"p+\" ) energy (float) : the kinetic energy of the cosmic ray, which can be used instead of the rigidity to set the momentum of the cosmic ray (default= None ). Cannot be used concurrently with the rigidity. bfield_type (str) : the type of magnetic field model that is being used (default= igrf ). One can set this to dipole to use the dipole approximation of Earth's magnetic field instead. date (str) : the date (yyyy/mm/dd) in which we want to simulate the cosmic ray trajectory (default is set to the current date). This will change the value of the Gauss coefficients associated with the IGRF model. 2. Evaluate the trajectory The next step is to evaluate the cosmic ray trajectory by using the numerical integrator. There are a few parameters that can be set to modify the integration: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s). Additionally, one can choose either to obtain the data of the trajectory in a dictionary format by setting the option get_data=True . This dictionary will return the trajectory data of the six-vector in spherical coordinates as well as the time as an array. The keys of the dictionary are as follows: [\"t\", \"r\", \"theta\", \"phi\", \"pr\", \"ptheta\", \"pphi\"] The evaluation is performed simply by one function call: traj.get_trajectory() # without trajectory data trajectory_data = traj.get_trajectory(get_data=True) # with data Optional steps The following step are performed one desires to visualize the trajectory as a plot. 3. Plot the results We can now plot the trajectory. We can either plot this using matplotlib , a standard Python module for plotting, or PlotLy , a HTML interface for interactive plots. The desired method is using PlotLy , which allows for plots obtained from both Python scripts and Jupyter cells to produce an interactive plot. This can be done by the following script: from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.png\", mpl=False, plot_path=\"../gtracr_plots\", title_name=\"Particle Trajectory\" ) There are several options available when visualizing the plot: file_name : the name of the file in which we save the plot to. This needs only to be the relative path within the directory in which the plot is saved in. This should have extensions in .html format for PlotLy plots, and some image format ( .png , .jpg etc) for matplotlib plots. mpl : choose whether to plot the trajectory using the matplotlib module with plt.axes(projection=\"3d\") (default : False). plot_dir : the path to the directory in which we store the plots. The default is set to \"gtracr_plots\", placed in parallel with the parent directory. title_name : the title of the plot. This should be changed to appropriately describe the trajectory plot. The plotter also implicitly converts the data (which is in spherical coordinates) into Cartesian coordinates. Note : To run this in JupyterLab, additional modeles are required to allow PlotLy to work. Check the PlotLy Installation Guide for more details. Running PlotLy on Jupyter Notebook still works without any additional requirements. Example Here we present a simple example that can be run in a Python script or a Jupyter Cell: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" )","title":"Evaluating a Single Trajectory"},{"location":"trajectory/#evaluating-a-single-trajectory","text":"Evaluating a single trajectory can be done seamlessly with a few steps.","title":"Evaluating a Single Trajectory"},{"location":"trajectory/#1-initialize-a-trajectory-object","text":"The first thing to do is to initalize the Trajectory object, which is a container for the specifications and initial configurations of the cosmic ray trajectory. To get the relavant module for the initialization of the trajectory: from gtracr.trajectory import Trajectory The required parameters to initialize the trajectory are as follows: location_name (str) : The name of the location in which we want to the detect the cosmic rays zenith_angle (float) : the zenith angle relative to the detector location in degrees ([0, 180]). Angles > 90 are for upwards-moving particles from the other end of the Earth. azimuth_angle (float) : the azimuthal angle relative to the detector location in degrees ([0, 360]). An angle of 0 degrees points to the Geographic South Pole. particle_altitude (float) : the altitude above sea level in which the cosmic ray arrives at in km rigidity (float) : the momentum per charge of the cosmic ray at the arrival location in GV For example, assume we want to simulate a cosmic ray that arrives at the horizon ( zenith_angle=90 ) from the West ( azimuth_angle=90 ) at 100km above sea level ( particle_altitude=100 ) at the Kamioka site ( location_name=\"Kamioka\" ) with a rigidity of 30 GV ( rigidity=30 ): traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90, azimuth_angle=90, particle_altitude=100, rigidity=30 ) There are other optional parameters that one can configure to initialize the Trajectory object. plabel (str) : the type of particle of the cosmic ray (default= \"p+\" ) energy (float) : the kinetic energy of the cosmic ray, which can be used instead of the rigidity to set the momentum of the cosmic ray (default= None ). Cannot be used concurrently with the rigidity. bfield_type (str) : the type of magnetic field model that is being used (default= igrf ). One can set this to dipole to use the dipole approximation of Earth's magnetic field instead. date (str) : the date (yyyy/mm/dd) in which we want to simulate the cosmic ray trajectory (default is set to the current date). This will change the value of the Gauss coefficients associated with the IGRF model.","title":"1. Initialize a Trajectory object."},{"location":"trajectory/#2-evaluate-the-trajectory","text":"The next step is to evaluate the cosmic ray trajectory by using the numerical integrator. There are a few parameters that can be set to modify the integration: dt : the step size of the integration, i.e. the time difference between each point in the trajectory (default : 1e-5s) max_time : the maximum time in which the integration occurs. No trajectory will be evaluated longer than this time (default : 1s). Additionally, one can choose either to obtain the data of the trajectory in a dictionary format by setting the option get_data=True . This dictionary will return the trajectory data of the six-vector in spherical coordinates as well as the time as an array. The keys of the dictionary are as follows: [\"t\", \"r\", \"theta\", \"phi\", \"pr\", \"ptheta\", \"pphi\"] The evaluation is performed simply by one function call: traj.get_trajectory() # without trajectory data trajectory_data = traj.get_trajectory(get_data=True) # with data","title":"2. Evaluate the trajectory"},{"location":"trajectory/#optional-steps","text":"The following step are performed one desires to visualize the trajectory as a plot.","title":"Optional steps"},{"location":"trajectory/#3-plot-the-results","text":"We can now plot the trajectory. We can either plot this using matplotlib , a standard Python module for plotting, or PlotLy , a HTML interface for interactive plots. The desired method is using PlotLy , which allows for plots obtained from both Python scripts and Jupyter cells to produce an interactive plot. This can be done by the following script: from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.png\", mpl=False, plot_path=\"../gtracr_plots\", title_name=\"Particle Trajectory\" ) There are several options available when visualizing the plot: file_name : the name of the file in which we save the plot to. This needs only to be the relative path within the directory in which the plot is saved in. This should have extensions in .html format for PlotLy plots, and some image format ( .png , .jpg etc) for matplotlib plots. mpl : choose whether to plot the trajectory using the matplotlib module with plt.axes(projection=\"3d\") (default : False). plot_dir : the path to the directory in which we store the plots. The default is set to \"gtracr_plots\", placed in parallel with the parent directory. title_name : the title of the plot. This should be changed to appropriately describe the trajectory plot. The plotter also implicitly converts the data (which is in spherical coordinates) into Cartesian coordinates. Note : To run this in JupyterLab, additional modeles are required to allow PlotLy to work. Check the PlotLy Installation Guide for more details. Running PlotLy on Jupyter Notebook still works without any additional requirements.","title":"3. Plot the results"},{"location":"trajectory/#example","text":"Here we present a simple example that can be run in a Python script or a Jupyter Cell: from gtracr.trajectory import Trajectory # initialize a cosmic ray trajectory that arrives at the horizon # from the West at 100km above sea level at the Kamioka site with # a rigidity of 30 GV: traj = Trajectory( location_name=\"Kamioka\", zenith_angle=90., azimuth_angle=90., particle_altitude=100., rigidity=30. ) # evaluate the trajectory and get the trajectory data trajectory_data = traj.get_trajectory(get_data=True) # plot the results from gtracr.plotting import plot_3dtraj plot_3dtraj( trajectory_data, file_name = \"plot.html\", plot_path=\"../gtracr_plots\" )","title":"Example"}]}